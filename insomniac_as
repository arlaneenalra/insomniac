()  ( -- () ) Puts an empty pair on the stack
[0-9]+ ( -- num )  Puts a numeric literal on the stack
#\<C>  ( -- c ) Puts a character literal on the stack
#t #f  ( -- b ) Puts true or false on the stack

"Hi"   ( -- s ) Puts a string literal on the stack
s"Hi"  ( -- sym ) Put a symbol literal on the stack

out  ( obj -- ) Outputs the object on top of the stack to stdout
               printf)
nop ( -- ) Does nothing
dup ( a -- a a)
swap ( a b -- b a)
rot (c b a -- a c b)
depth ( -- depth ) How deep is the stack?
sym    ( str -- sym ) Takes a string and makes it into a symbol

cons   ( car cdr -- (car . cdr) ) Takes the top two stack entries and
                                  makes them into a pair
car    ( pair -- car ) Return the car of the pair
cdr    ( pair -- cdr ) Return the cdr of the pair
set-car ( pair val -- pair ) Returns the pair with it's car modified
set-cdr ( pair val -- pair ) Returns the pair with it's cdr modified

vector ( size -- vector ) Makes a vector of the given size
vec@ ( index vector -- obj ) Takes an index and vector and
                                retrieves the object at the given
                                index
vec! ( index obj vector -- ) Takes an index, object, and vector and
                                stores the object at the given index
jmp  ( -label- ) Jumps to given label
jnf  ( obj -label- ) Jumps to the given label if obj is not false

continue ( -label- ) Sets the location of an exception handling routine

call ( -label- closure ) Converts the location following this
                         instruction to closure and leaves it on the
                         stack then jumps to the label.
proc ( -label- closure ) Creates a closure that begins execution at
                         the given label.

ret ( closure -- ) Synonym for jin
jin ( closure -- ) Return to the location left on the stack and
                   replace the current environment with the one
                   associated with that location

bind ( value sym -- ) Binds a symbol in the current environemnt
! ( value sym -- ) Stores a value at the given symbol, must already
                   exist
@ ( sym -- value ) Load the value stored in a symbol

+ ( a b -- a+b )
- ( a b -- a-b )
* ( a b -- a*b )
/ ( a b -- a/b )
% ( a b -- a%b ) 

Numberic comparisons
= ( a b -- a==b ) 
< ( a b -- a<b )
> ( a b -- a>b )

not ( bool -- !bool) if false is on top of the stack, returns true,
                     otherwise false
eq  ( a b -- a eq b) Simple equivalence operations works for most
                     primitive types and checks to see if complex
                     object references are the same object

